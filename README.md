Нелинейные системы автоматического управления. Основные свойства и характеристики
. Что это? Это системы, описываемые нелинейными дифференциальными уравнениями. В отличие от линейных, принцип суперпозиции к ним неприменим.
· Основные свойства (отличия от линейных систем):
  1. Неприменимость принципа суперпозиции: Реакция системы на сумму воздействий не равна сумме реакций на каждое воздействие отдельно.
  2. Зависимость свойств от входного сигнала: Переходная характеристика, устойчивость и другие показатели качества могут кардинально меняться в зависимости от амплитуды и начальных условий.
  3. Наличие специфических режимов:
     · Автоколебания: Установившиеся незатухающие колебания определенной амплитуды и частоты, возникающие внутри системы без внешнего периодического воздействия. Характерный признак нелинейности.
     · Скользящие режимы: Возникают в системах с переменной структурой (релейные системы).
     · Эффект запаздывания (гистерезис): Разные реакции при увеличении и уменьшении воздействия.
     · Релейный характер: Резкое, скачкообразное изменение сигнала (например, двух- или трехпозиционное реле).
· Основные характеристики:
  · Статическая характеристика: Зависимость y = F(x) выходной величины от входной в установившемся режиме. Может быть нелинейной (например, зона нечувствительности, насыщение, люфт).
  · Фазовая траектория: График зависимости одной переменной состояния от другой.

---

Фазовое пространство

· Что это? Это координатное пространство, по осям которого откладываются переменные состояния системы (фазовые координаты): x1(t), x2(t), ..., xn(t). Для системы 2-го порядка — это фазовая плоскость.
· Зачем нужно? Позволяет наглядно представить все возможные состояния системы и ее динамику во времени без явного решения дифференциальных уравнений.
· Ключевые понятия:
  · Фазовая траектория: Линия в фазовом пространстве, показывающая эволюцию системы из некоторого начального состояния.
  · Особые точки: Точки, в которых производные всех фазовых координат равны нулю (dx_i/dt = 0). Соответствуют состояниям равновесия системы. Их тип (узел, фокус, седло, центр) определяет поведение системы в малой окрестности.
  · Предельный цикл: Изолированная замкнутая фазовая траектория. Соответствует автоколебательному режиму. Устойчивый предельный цикл "притягивает" соседние траектории — это и есть автоколебания.

---

Устойчивость и автоколебания нелинейных систем

· Устойчивость: Понятие сложнее, чем в линейных системах. Различают:
  · Устойчивость "в малом" (в окрестности точки равновесия).
  · Устойчивость "в большом" (при любых начальных условиях).
  · Нелинейная система может иметь несколько состояний равновесия, одни из которых устойчивы, другие — нет.
· Автоколебания: Это устойчивые периодические колебания, которым соответствует устойчивый предельный цикл на фазовой плоскости. Они не зависят от начальных условий (в отличие от консервативных систем, где амплитуда зависит от начальной энергии). Их амплитуда и частота определяются параметрами самой системы.

---

Первый и второй методы А.М. Ляпунова

Это методы исследования устойчивости без решения дифференциальных уравнений.

1. Первый метод Ляпунова (метод линеаризации):
   · Суть: Исследование устойчивости нелинейной системы в малой окрестности точки равновесия путем ее линеаризации (разложение в ряд Тейлора и отбрасывание нелинейных членов).
   · Результат: Если все корни характеристического уравнения линеаризованной системы имеют отрицательные вещественные части, то исходная нелинейная система асимптотически устойчива в малом. Если есть хоть один корень с положительной вещественной частью — неустойчива. Если есть корни на мнимой оси — неопределенность (устойчивость нельзя определить линеаризацией, нужно применять второй метод).
2. Второй метод Ляпунова (прямой метод):
   · Суть: Подбор специальной функции V(x1, x2, ..., xn) — функции Ляпунова, которая является аналогом энергии системы. Анализируется ее производная в силу уравнений системы.
   · Интерпретация:
     · V(x) > 0 (положительно определена), dV/dt < 0 (отрицательно определена) -> система асимптотически устойчива.
     · V(x) > 0, dV/dt <= 0 -> система устойчива по Ляпунову.
     · dV/dt > 0 -> система неустойчива.
   · Преимущество: Позволяет исследовать устойчивость "в большом" и для случаев, когда первый метод не работает.

---

Абсолютная устойчивость по В.М. Попову

· Проблема: Класс систем, где нелинейность F(σ) является произвольной функцией, но принадлежащей заданному сектору (например, 0 <= F(σ)/σ <= k). Это типично для систем с неопределенностью вида нелинейности.
· Цель метода: Найти условия на параметры линейной части системы, при которых система будет устойчива для любой нелинейности из заданного сектора. То есть обеспечить абсолютную устойчивость.
· Метод Попова: Частотный критерий, обобщение критерия Найквиста для нелинейных систем. Используется модифицированная частотная характеристика линейной части и строится "линия Попова" на графике. Условие абсолютной устойчивости формулируется графически или аналитически.

---

Исследование нелинейных систем методами точечных преобразований и гармонической линеаризации

1. Метод точечных преобразований (метод Пуанкаре):
   · Суть: Построение функции последования (отображения). Динамика системы высокого порядка изучается через дискретное отображение одной переменной на себя (например, через секущую Пуанкаре).
   · Применение: Особенно эффективен для анализа релейных систем и систем 2-го порядка. Позволяет находить периодические решения (неподвижные точки отображения) и исследовать их устойчивость.
2. Метод гармонической линеаризации (метод описывающих функций):
   · Идея: Замена нелинейного элемента его "эквивалентным" комплексным коэффициентом усиления (q(A)), который зависит от амплитуды A входного гармонического сигнала.
   · Условие применимости: Линейная часть системы должна быть низкочастотным фильтром (подавлять высшие гармоники).
   · Цель: Нахождение условий возникновения автоколебаний. Для этого записывается уравнение замкнутой системы: W_л(jω) * q(A) = -1.
   · Графическое решение: Строится АФХ линейной части W_л(jω) и годограф -1/q(A). Точка пересечения этих кривых соответствует возможным автоколебаниям. По взаимному расположению графиков определяется устойчивость этих колебаний.

---

Системы с переменной структурой (СПС)

· Что это? Системы, структура (алгоритм управления) которых целенаправленно меняется в зависимости от текущего состояния системы.
· Ключевой элемент: Обычно содержит релейные или ключевые элементы.
· Скользящий режим (СР): Основной режим работы СПС. Фазовые траектории с разных сторон "наезжают" на некоторую поверхность (линию) переключения s(x)=0 и далее движутся по ней к началу координат.
· Достоинства:
  · Робастность (инвариантность): В идеальном скользящем режиме система нечувствительна к изменению параметров объекта управления и внешним возмущениям.
  · Высокое быстродействие.
· Недостаток: Зазмыкание (высокочастотные колебания) из-за неидеальности переключающих элементов (задержки, гистерезис).

---

методы Ляпунова и Попова с примерами на Python.

---

Методы А.М. Ляпунова: Глубокое погружение

Основная идея Ляпунова — определить устойчивость системы, не решая сложных нелинейных дифференциальных уравнений.

Первый метод Ляпунова (Метод линеаризации)

Суть метода: Мы исследуем поведение системы не вдали, а очень близко к точке равновесия. В этой малой окрестности нелинейную систему можно приближенно заменить ее линейной версией. Устойчивость этой линейной "копии" и расскажет нам об устойчивости исходной нелинейной системы в малом.

Как это работает:

1. Найти точки равновесия. Решаем систему уравнений dx/dt = 0.
2. Линеаризовать систему вокруг каждой точки равновесия. Для этого вычисляем матрицу Якоби (матрицу первых частных производных правых частей уравнений системы).
3. Найти собственные числа (λ) матрицы Якоби.
4. Сделать вывод:
   · Если все Re(λ) < 0 → Система асимптотически устойчива в малом.
   · Если хотя бы одно Re(λ) > 0 → Система неустойчива.
   · Если есть Re(λ) = 0 → Неопределенный случай. Первый метод не дает ответа. Нужно использовать второй метод или другие средства.

Пример на Python: Анализ маятника с трением

Рассмотрим маятник: угол θ, скорость ω. Уравнения: dθ/dt = ω dω/dt = -b*ω - sin(θ)(где b — коэффициент трения)

```python
import numpy as np
from scipy.linalg import eig
import matplotlib.pyplot as plt

# Параметры
b = 0.5  # коэффициент трения

# Точки равновесия: (0,0) и (π, 0) (висящий и перевернутый маятник)
equilibrium_points = [(0, 0), (np.pi, 0)]

# Матрица Якоби для нашей системы:
# df1/dθ = 0,        df1/dω = 1
# df2/dθ = -cos(θ), df2/dω = -b
def jacobian(theta, omega):
    return np.array([
        [0, 1],
        [-np.cos(theta), -b]
    ])

# Анализируем каждую точку равновесия
for point in equilibrium_points:
    theta_eq, omega_eq = point
    J = jacobian(theta_eq, omega_eq)
    eigenvalues, _ = eig(J)
    print(f"Точка равновесия ({theta_eq:.2f}, {omega_eq:.2f}):")
    print(f"  Матрица Якоби:\n{J}")
    print(f"  Собственные числа: {eigenvalues}")
    
    # Проверяем устойчивость
    if all(np.real(eigenvalues) < 0):
        print("  Вывод: Асимптотически устойчива.\n")
    elif any(np.real(eigenvalues) > 0):
        print("  Вывод: Неустойчива.\n")
    else:
        print("  Вывод: Неопределенный случай (на границе устойчивости).\n")
```

Что мы сделали и что увидим:

1. Для точки (0, 0): Матрица Якоби будет [[0, 1], [-1, -0.5]]. Ее собственные числа будут иметь отрицательные вещественные части (например, -0.25 ± 0.66j). Вывод: устойчивый фокус. Маятник будет медленно затухать к нижнему положению.
2. Для точки (π, 0) (перевернутое положение): Матрица Якоби будет [[0, 1], [1, -0.5]]. Одно из собственных чисел будет положительным (например, ~0.89). Вывод: неустойчиво (седло). Любое малейшее отклонение от этой точки приведет к падению маятника.

---

Второй метод Ляпунова (Прямой метод)

Суть метода: Это более мощный и общий метод. Мы ищем функцию V(x), которая является аналогом "обобщенной энергии" системы. Если эта функция всегда положительна и ее производная вдоль траекторий системы всегда отрицательна, то система стремится к состоянию с минимальной "энергией", т.е. к точке равновесия.

Как это работает:

1. Придумать кандидата в функции Ляпунова V(x). Это самая сложная часть. Часто берут квадратичную форму: V(x) = x₁² + x₂².
2. Проверить положительную определенность: V(x) > 0 для всех x ≠ 0 и V(0) = 0.
3. Вычислить полную производную по времени: dV/dt = (∂V/∂x₁)*dx₁/dt + (∂V/∂x₂)*dx₂/dt + .... Подставляем в нее исходные уравнения системы.
4. Проанализировать производную dV/dt:
   · Если dV/dt < 0 для всех x ≠ 0 → Система асимптотически устойчива.
   · Если dV/dt <= 0 → Система просто устойчива (может быть незатухающие колебания).
   · Если dV/dt > 0 → Система неустойчива.

Пример на Python: Исследование нелинейной системы

Рассмотрим систему: dx/dt = y - x³ dy/dt = -x - y³

Попробуем функцию V(x, y) = x² + y².

```python
# Определим систему уравнений
def system(state, t):
    x, y = state
    dx_dt = y - x**3
    dy_dt = -x - y**3
    return [dx_dt, dy_dt]

# Определим функцию Ляпунова и ее производную
def V(x, y):
    return x**2 + y**2

def dV_dt(x, y):
    # dV/dt = 2x*(dx/dt) + 2y*(dy/dt)
    # Подставляем уравнения системы:
    return 2*x*(y - x**3) + 2*y*(-x - y**3)
    # Раскрываем скобки:
    return 2*x*y - 2*x**4 - 2*x*y - 2*y**4
    # Упрощаем (2xy и -2xy уничтожаются):
    return -2*x**4 - 2*y**4

# Визуализируем V и dV/dt
x = np.linspace(-2, 2, 50)
y = np.linspace(-2, 2, 50)
X, Y = np.meshgrid(x, y)

Z_V = V(X, Y)
Z_dV_dt = dV_dt(X, Y) # Всегда <= 0

# Построим графики
plt.figure(figsize=(12, 5))

plt.subplot(1, 2, 1)
plt.contourf(X, Y, Z_V, levels=20, cmap='viridis')
plt.colorbar(label='V(x,y)')
plt.title('Функция Ляпунова V(x,y) = x² + y²')
plt.xlabel('x')
plt.ylabel('y')

plt.subplot(1, 2, 2)
plt.contourf(X, Y, Z_dV_dt, levels=20, cmap='RdBu')
plt.colorbar(label='dV/dt')
plt.title('Производная dV/dt = -2x⁴ - 2y⁴')
plt.xlabel('x')
plt.ylabel('y')

plt.tight_layout()
plt.show()

# Проверим знаки
print(f"V(x,y) всегда неотрицательна? {np.all(Z_V >= 0)}")
print(f"V(x,y) равна нулю только в (0,0)? {np.allclose(V(0,0), 0) and not np.any(np.isclose(Z_V[1:-1, 1:-1], 0))}") # Проверка среза без краев
print(f"dV/dt всегда неположительна? {np.all(Z_dV_dt <= 0)}")
print(f"dV/dt равна нулю только в (0,0)? {np.allclose(dV_dt(0,0), 0) and not np.any(np.isclose(Z_dV_dt[1:-1, 1:-1], 0))}")
```

Вывод:

· График слева показывает "чашу": V(x,y) всегда положительна и равна нулю только в начале координат.
· График справа показывает, что dV/dt всегда отрицательна везде, кроме точки (0,0), где она равна нулю.

Это идеальное соответствие второму методу Ляпунова: наша кандидатская функция доказала, что система глобально асимптотически устойчива. Все траектории стягиваются в начало координат.

---

Метод В.М. Попова: Глубокое погружение

Суть метода: Мы хотим гарантировать, что нелинейная система будет устойчива абсолютно, то есть при любой форме нелинейности, лишь бы она не выходила за рамки заданного сектора. Это мощный инструмент для анализа робастной устойчивости.

Постановка задачи: Есть система с обратной связью:

1. Линейная часть с передаточной функцией W(s).
2. Нелинейный элемент φ(σ) в обратной связи. Нелинейность ограничена сектором:0 <= φ(σ)/σ <= k для всех σ ≠ 0. Это значит, что график нелинейности лежит между прямой y=0 и y=kσ.

Критерий Попова (частотная формулировка): Для абсолютной устойчивости системы достаточно,чтобы существовало такое действительное число q, что для всех ω >= 0 выполняется следующее неравенство:

Re( (1 + jωq) * W(jω) ) + 1/k > 0

Геометрическая интерпретация (самый простой способ):

1. Построить модифицированную частотную характеристику Попова: W*(jω) = Re(W(jω)) + jωIm(W(jω)).
2. Найти на действительной оси точку -1/k.
3. Попробовать провести через эту точку прямую так, чтобы весь годограф W*(jω) лежал справа от этой прямой.
4. Если такая прямая существует — система абсолютно устойчива.

Пример на Python: Анализ абсолютной устойчивости

Допустим, у нас есть линейная часть W(s) = 1/((s+1)(s+2)(s+3)) и нелинейность в секторе [0, k=2].

```python
from scipy import signal

# 1. Зададим линейную систему
numerator = [1]
denominator = [1, 6, 11, 6]  # (s+1)(s+2)(s+3) = s^3 + 6s^2 + 11s + 6
sys = signal.lti(numerator, denominator)

# 2. Рассчитаем обычную АФХ (Найквист)
w = np.logspace(-2, 2, 1000)
w, H = signal.freqresp(sys, w)
U_nyq = H.real
V_nyq = H.imag

# 3. Рассчитаем модифицированную АФХ (Попов)
U_popov = U_nyq
V_popov = w * V_nyq  # KEY: jω * Im(W(jω))

# 4. Зададим параметры сектора
k = 2.0
critical_point = (-1/k, 0.0)  # Точка -1/k на действительной оси

# 5. Построим оба годографа
plt.figure(figsize=(10, 6))

# Годограф Найквиста
plt.plot(U_nyq, V_nyq, label='Годограф Найквиста: Re(W), Im(W)')
# Годограф Попова
plt.plot(U_popov, V_popov, label='Годограф Попова: Re(W), ω*Im(W)', color='orange', linewidth=2)
# Критическая точка
plt.scatter(critical_point[0], critical_point[1], color='red', s=80, zorder=5, label=f'Критическая точка (-1/k, 0) для k={k}')

# Пробуем провести "линию Попова" через критическую точку.
# Ее наклон определяется параметром q. Подберем его визуально.
q = 0.5
# Уравнение линии: y = q*(x - (-1/k)) + 0 => y = q*(x + 1/k)
x_line = np.linspace(-0.8, 0.1, 100)
y_line = q * (x_line + 1/k)
plt.plot(x_line, y_line, 'r--', label=f'Линия Попова (q={q})')

# Оформление графика
plt.axvline(0, color='black', linestyle='--', linewidth=0.5)
plt.axhline(0, color='black', linestyle='--', linewidth=0.5)
plt.xlabel('Re')
plt.ylabel('Im / ω*Im')
plt.title('Критерий абсолютной устойчивости Попова')
plt.legend()
plt.grid(True)
plt.axis('equal')  # Важно для корректного отображения формы годографа
plt.show()

# 6. Анализ: Весь оранжевый годограф Попова лежит справа от красной пунктирной линии?
# Если ДА, то система абсолютно устойчива в секторе [0, 2].
```

Анализ графика: На графике мы видим:

· Синий годограф Найквиста: Он может даже заходить в отрицательную полуплоскость, что для нелинейной системы не обязательно означает неустойчивость.
· Оранжевый годограф Попова: Он "выпрямлен" и сдвинут.
· Красная пунктирная линия: Мы успешно провели ее через критическую точку (-0.5, 0) так, что весь оранжевый годограф лежит строго справа от этой линии.

Вывод: Данная система абсолютно устойчива для любой нелинейности φ(σ), лежащей в секторе [0, 2]. Это означает, что какую бы конкретную форму внутри этого сектора ни имела нелинейность (насыщение, реле и т.д.), вся замкнутая система будет устойчива.

Это гораздо более сильное утверждение, чем может дать анализ по Найквисту для линейных систем, и в этом сила метода Попова

методы точечных преобразований и гармонической линеаризации — два мощных инструмента анализа нелинейных систем.

---

Метод гармонической линеаризации (Метод описывающих функций)

Теоретическое обоснование

Основная идея: Замена нелинейного элемента эквивалентным линейным оператором, зависящим от амплитуды входного сигнала. Этот метод позволяет предсказать возникновение автоколебаний.

Условия применимости:

1. Нелинейность должна быть статической (без памяти)
2. Линейная часть системы должна быть низкочастотным фильтром — эффективно подавлять высшие гармоники

Математическая основа: Если на вход нелинейного элемента подать гармонический сигналx(t) = A·sin(ωt), то выходной сигнал можно разложить в ряд Фурье: y(t) = (A₀/2) + Σ[Aₙ·cos(nωt) + Bₙ·sin(nωt)]

Коэффициент гармонической линеаризации (описывающая функция) определяется как отношение первой гармоники выходного сигнала к входному: N(A) = (B₁ + jA₁)/A

Примеры описывающих функций для типовых нелинейностей

```python
import numpy as np
import matplotlib.pyplot as plt

# 1. Идеальное реле
def N_ideal_relay(A, c):
    """c - выходной уровень реле"""
    if A == 0:
        return 0
    return 4*c/(np.pi*A) + 0j

# 2. Реле с зоной нечувствительности
def N_relay_deadzone(A, b, c):
    """b - зона нечувствительности, c - выходной уровень"""
    if A <= b:
        return 0
    return (4*c/(np.pi*A)) * np.sqrt(1 - (b/A)**2) + 0j

# 3. Реле с гистерезисом
def N_relay_hysteresis(A, b, c):
    """b - ширина гистерезиса, c - выходной уровень"""
    if A <= b:
        return 0
    return (4*c/(np.pi*A)) * (np.sqrt(1 - (b/A)**2) - 1j*(b/A)) 

# 4. Нелинейность типа "насыщение"
def N_saturation(A, a, k):
    """a - уровень насыщения, k - коэффициент усиления"""
    if A <= a:
        return k + 0j
    return (2*k/np.pi) * (np.arcsin(a/A) + (a/A)*np.sqrt(1 - (a/A)**2)) + 0j

# Визуализация описывающих функций
A = np.linspace(0.1, 5, 1000)

plt.figure(figsize=(12, 8))

# Идеальное реле (c=1)
N1 = [N_ideal_relay(a, 1) for a in A]
plt.subplot(2, 2, 1)
plt.plot(A, np.real(N1), label='Re(N)')
plt.plot(A, np.imag(N1), label='Im(N)')
plt.title('Идеальное реле (c=1)')
plt.xlabel('Амплитуда A')
plt.ylabel('N(A)')
plt.legend()
plt.grid(True)

# Реле с зоной нечувствительности (b=1, c=1)
N2 = [N_relay_deadzone(a, 1, 1) for a in A]
plt.subplot(2, 2, 2)
plt.plot(A, np.real(N2), label='Re(N)')
plt.plot(A, np.imag(N2), label='Im(N)')
plt.title('Реле с зоной нечувствительности (b=1, c=1)')
plt.xlabel('Амплитуда A')
plt.ylabel('N(A)')
plt.legend()
plt.grid(True)

# Реле с гистерезисом (b=1, c=1)
N3 = [N_relay_hysteresis(a, 1, 1) for a in A]
plt.subplot(2, 2, 3)
plt.plot(A, np.real(N3), label='Re(N)')
plt.plot(A, np.imag(N3), label='Im(N)')
plt.title('Реле с гистерезисом (b=1, c=1)')
plt.xlabel('Амплитуда A')
plt.ylabel('N(A)')
plt.legend()
plt.grid(True)

# Насыщение (a=1, k=2)
N4 = [N_saturation(a, 1, 2) for a in A]
plt.subplot(2, 2, 4)
plt.plot(A, np.real(N4), label='Re(N)')
plt.plot(A, np.imag(N4), label='Im(N)')
plt.title('Насыщение (a=1, k=2)')
plt.xlabel('Амплитуда A')
plt.ylabel('N(A)')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()
```

Определение параметров автоколебаний

Условие возникновения автоколебаний: W(jω)·N(A) = -1

Это уравнение можно решить графически или численно:

```python
from scipy import signal
from scipy.optimize import fsolve

# Зададим линейную часть системы
# W(s) = 1/((s+1)(s+2)(s+3))
num = [1]
den = [1, 6, 11, 6]  # (s+1)(s+2)(s+3) = s³ + 6s² + 11s + 6
sys = signal.lti(num, den)

# Рассчитаем АФХ линейной части
w = np.logspace(-1, 1, 1000)
w, H = signal.freqresp(sys, w)
U = H.real
V = H.imag

# Функция для решения уравнения автоколебаний
def oscillation_condition(params):
    A, omega = params
    # Вычисляем N(A) для идеального реле (c=1)
    N_A = N_ideal_relay(A, 1)
    # Вычисляем W(jω)
    W_jw = sys(1j*omega)[1]  # sys(1j*omega) возвращает (array, array), берем второй элемент
    # Уравнение: 1 + W(jω)N(A) = 0
    equation = 1 + W_jw * N_A
    return [np.real(equation), np.imag(equation)]

# Начальное приближение для решения
initial_guess = [1.0, 2.0]  # A=1, ω=2

# Решаем уравнение
solution = fsolve(oscillation_condition, initial_guess)
A_sol, omega_sol = solution

print(f"Найденные параметры автоколебаний: A = {A_sol:.3f}, ω = {omega_sol:.3f} рад/с")

# Проверим условие
N_A_sol = N_ideal_relay(A_sol, 1)
W_jw_sol = sys(1j*omega_sol)[1]
check = 1 + W_jw_sol * N_A_sol
print(f"Проверка: 1 + W(jω)N(A) = {check:.6f}")

# Графическая проверка: построим годографы
plt.figure(figsize=(10, 6))
plt.plot(U, V, label='Годограф Найквиста W(jω)')
plt.plot(-1/np.real(N_A_sol), 0, 'ro', label='Точка -1/N(A)')
plt.axhline(0, color='black', linestyle='--', linewidth=0.5)
plt.axvline(0, color='black', linestyle='--', linewidth=0.5)
plt.xlabel('Re')
plt.ylabel('Im')
plt.title('Графический анализ автоколебаний')
plt.legend()
plt.grid(True)
plt.axis('equal')
plt.show()
```

---

Метод точечных преобразований (метод Пуанкаре)

Теоретическое обоснование

Основная идея: Сведение анализа многомерной динамической системы к изучению одномерного отображения — функции последования.

Алгоритм метода:

1. Выбрать секущую поверхность (для систем 2-го порядка — прямую линию)
2. Рассмотреть последовательность точек пересечения траектории с этой поверхностью
3. Построить отображение xₙ₊₁ = f(xₙ), где xₙ — координата n-го пересечения
4. Исследовать полученное одномерное отображение

Неподвижные точки отображения соответствуют периодическим движениям системы.

Пример анализа релейной системы

Рассмотрим систему: ẋ = y ẏ = -x - y + u гдеu = -sign(x) (идеальное реле)

```python
from scipy.integrate import solve_ivp

# Определяем систему дифференциальных уравнений
def relay_system(t, state):
    x, y = state
    # Управление - идеальное реле
    u = -1 if x >= 0 else 1
    dx_dt = y
    dy_dt = -x - y + u
    return [dx_dt, dy_dt]

# Функция для обнаружения пересечений с секущей
def find_crossings(sol, direction='positive'):
    """Находит пересечения траектории с осью x=0"""
    crossings = []
    x_vals = sol.y[0]
    y_vals = sol.y[1]
    t_vals = sol.t
    
    for i in range(1, len(t_vals)):
        if x_vals[i-1] * x_vals[i] < 0:  # Знак x изменился
            # Линейная интерполяция для более точного определения
            t_cross = t_vals[i-1] + (t_vals[i] - t_vals[i-1]) * (-x_vals[i-1])/(x_vals[i] - x_vals[i-1])
            # Определяем направление пересечения
            if direction == 'positive' and y_vals[i] > 0:
                crossings.append((t_cross, y_vals[i]))
            elif direction == 'negative' and y_vals[i] < 0:
                crossings.append((t_cross, y_vals[i]))
    return crossings

# Моделируем систему
t_span = [0, 50]
initial_state = [0.1, 0]  # Начальное условие близко к секущей x=0

sol = solve_ivp(relay_system, t_span, initial_state, 
                method='RK45', dense_output=True, rtol=1e-6, atol=1e-9)

# Находим пересечения с секущей x=0
crossings = find_crossings(sol, 'positive')
y_crossings = [cross[1] for cross in crossings]

# Строим фазовый портрет
plt.figure(figsize=(12, 5))

plt.subplot(1, 2, 1)
plt.plot(sol.y[0], sol.y[1])
plt.xlabel('x')
plt.ylabel('y')
plt.title('Фазовый портрет системы')
plt.grid(True)
plt.axhline(0, color='black', linestyle='--', linewidth=0.5)
plt.axvline(0, color='black', linestyle='--', linewidth=0.5)

# Отмечаем точки пересечения с секущей
for i, cross in enumerate(crossings[:10]):  # Первые 10 пересечений
    plt.plot(0, cross[1], 'ro')
    plt.text(0.1, cross[1], f'{i+1}', fontsize=8)

# Строим функцию последования
plt.subplot(1, 2, 2)
plt.plot(y_crossings[:-1], y_crossings[1:], 'o-')
plt.plot([min(y_crossings), max(y_crossings)], 
         [min(y_crossings), max(y_crossings)], 'r--', label='y_{n+1} = y_n')
plt.xlabel('y_n')
plt.ylabel('y_{n+1}')
plt.title('Функция последования')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

# Анализируем устойчивость предельного цикла
if len(y_crossings) > 2:
    # Оцениваем производную функции последования в последней точке
    dy = (y_crossings[-1] - y_crossings[-2]) / (y_crossings[-2] - y_crossings[-3])
    print(f"Производная функции последования: {dy:.3f}")
    
    if abs(dy) < 1:
        print("Предельный цикл устойчив")
    else:
        print("Предельный цикл неустойчив")
```

Расширенный пример: анализ бифуркаций

Метод точечных преобразований особенно полезен для исследования бифуркаций — качественных изменений поведения системы при изменении параметров.

```python
# Исследуем бифуркации в системе Ван дер Поля
def van_der_pol(t, state, mu):
    x, y = state
    dx_dt = y
    dy_dt = mu * (1 - x**2) * y - x
    return [dx_dt, dy_dt]

# Функция для построения бифуркационной диаграммы
def bifurcation_diagram(mu_values, initial_state=[0.1, 0], n_transient=100, n_steady=50):
    """Построение бифуркационной диаграммы"""
    bifurcation_data = []
    
    for mu in mu_values:
        # Моделируем систему
        sol = solve_ivp(van_der_pol, [0, 1000], initial_state, 
                        args=(mu,), method='RK45', dense_output=True)
        
        # Находим пересечения с секущей x=0
        crossings = find_crossings(sol, 'positive')
        y_values = [cross[1] for cross in crossings]
        
        # Отбрасываем переходный процесс
        if len(y_values) > n_transient + n_steady:
            steady_state = y_values[n_transient:n_transient+n_steady]
            for y in steady_state:
                bifurcation_data.append((mu, y))
    
    return bifurcation_data

# Строим бифуркационную диаграмму
mu_values = np.linspace(0.1, 3.0, 100)
bif_data = bifurcation_diagram(mu_values)

# Визуализируем
plt.figure(figsize=(10, 6))
mu_vals = [point[0] for point in bif_data]
y_vals = [point[1] for point in bif_data]
plt.plot(mu_vals, y_vals, '.', markersize=1)
plt.xlabel('Параметр μ')
plt.ylabel('y в точке пересечения')
plt.title('Бифуркационная диаграмма системы Ван дер Поля')
plt.grid(True)
plt.show()
```

---

Сравнение методов

Характеристика Метод гармонической линеаризации Метод точечных преобразований
Область применения Слабо нелинейные системы Сильно нелинейные системы
Тип анализа Приближенный, частотный Точный, временной
Основная цель Предсказание автоколебаний Исследование периодических решений
Сложность реализации Средняя Высокая
Точность результатов Приближенная Высокая (для низкоразмерных систем)
Возможность анализа устойчивости Да (критерий Найквиста) Да (через производную отображения)

Практические рекомендации

1. Метод гармонической линеаризации лучше подходит для:
   · Предварительного анализа систем
   · Оценки параметров автоколебаний
   · Синтеза корректирующих устройств
2. Метод точечных преобразований эффективен для:
   · Точного анализа релейных систем
   · Исследования бифуркаций
   · Анализа сложных динамических режимов
3. Комбинированный подход: Часто оба метода используются вместе:
   · Гармоническая линеаризация для первоначальной оценки
   · Точечные преобразования для уточнения результатов

Оба метода являются мощными инструментами для анализа нелинейных систем и позволяют получить ценную информацию о динамике системы, которую невозможно получить методами линейного анализа.
